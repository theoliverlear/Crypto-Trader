name: Build & Publish Crypto-Trader-Docs

on:
  push:
    branches: [ main ]
  workflow_dispatch:

concurrency:
  group: pages-${{ github.ref }}
  cancel-in-progress: true

permissions:
  contents: read
  packages: read
  # pages/id-token moved to deploy job

jobs:
  build:
    runs-on: ubuntu-latest
    env:
      GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      GITHUB_ACTOR: ${{ github.actor }}
      DJANGO_SECRET_KEY: ${{ secrets.DJANGO_SECRET_KEY }}
      OPENAI_KEY: ${{ secrets.OPENAI_KEY }}
      PSQL_DB_URL: ${{ secrets.PSQL_DB_URL }}
      PSQL_HOST: ${{ secrets.PSQL_HOST }}
      PSQL_PW: ${{ secrets.PSQL_PW }}
      PSQL_USER: ${{ secrets.PSQL_USER }}
      PYTHONUNBUFFERED: ${{ secrets.PYTHONUNBUFFERED }}
      WORLDNEWS_API_KEY: ${{ secrets.WORLDNEWS_API_KEY }}
      X_ACCESS_SECRET: ${{ secrets.X_ACCESS_SECRET }}
      X_ACCESS_TOKEN: ${{ secrets.X_ACCESS_TOKEN }}
      X_API_KEY: ${{ secrets.X_API_KEY }}
      X_SECRET: ${{ secrets.X_SECRET }}
      REPO_NAME: ${{ secrets.REPO_NAME }}
      APP_NAME: ${{ secrets.APP_NAME }}
    outputs:
      pages_enabled: ${{ steps.pages.outcome }}
      site_ready: ${{ steps.verify_site.outputs.site_ready }}

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Set up Java (23)
        uses: actions/setup-java@v4
        with:
          distribution: temurin
          java-version: '23'
          cache: 'maven'

      # Generate Dokka once (no need for full reactor install first)
      - name: Generate Dokka for all modules
        run: mvn -B -s .github/maven-settings.xml -DskipTests -am -U package org.jetbrains.dokka:dokka-maven-plugin:1.9.20:dokka

      - name: Start Kafka (docker-compose)
        run: |
          set -euo pipefail
          docker compose -f infra/kafka/docker-compose.yml up -d
          # Wait for Kafka (port 9092) to be reachable
          for i in $(seq 1 60); do
            if timeout 1 bash -c 'cat </dev/null >/dev/tcp/127.0.0.1/9092' 2>/dev/null; then
              echo "Kafka is up"
              break
            fi
            echo "Waiting for Kafka... ($i/60)"
            sleep 2
          done
          if ! timeout 1 bash -c 'cat </dev/null >/dev/tcp/127.0.0.1/9092' 2>/dev/null; then
            echo "::error::Kafka failed to start on port 9092"
            docker compose -f infra/kafka/docker-compose.yml logs || true
            exit 1
          fi

      # Start all services with docs profile, wait until /v3/api-docs.yaml is up, fail fast if any process exits
      - name: Start services (docs profile) and wait
        run: |
          set -euo pipefail
          shopt -s nullglob

          SERVICES=$(cat <<'EOF'
          api      Crypto-Trader-Api      18080   ""
          data     Crypto-Trader-Data     18081   "--cryptotrader.loadCurrencies=false"
          engine   Crypto-Trader-Engine   18082   "--cryptotrader.engine.trading.enabled=false"
          contact  Crypto-Trader-Contact  18083   "--cryptotrader.engine.trading.enabled=false"
          EOF
          )

          start_one () {
            local name="$1" module="$2" port="$3" extra="$4"
            echo "==> starting $name on :$port ($module)"
            nohup mvn -B -s .github/maven-settings.xml -DskipTests \
              -f "$module/pom.xml" -am \
              -Dspring-boot.run.profiles=docs \
              -Dspring-boot.run.arguments="--server.port=$port $extra" \
              spring-boot:run > "$name.log" 2>&1 &
            echo $! > "$name.pid"
          }

          echo "$SERVICES" | awk 'NF && $1 !~ /^#/' | while read -r name module port extra; do
            start_one "$name" "$module" "$port" "$extra"
          done

          die() {
            echo "::error::$1"
            echo "---- tail logs ----"
            tail -n 200 *.log || true
            exit 1
          }

          probe() {
            local port="$1"
            # Consider endpoint ready only if response body is non-empty (>20 bytes)
            local tmp=".probe_${port}.out"
            rm -f "$tmp"
            if curl -fsS "http://localhost:${port}/v3/api-docs.yaml" -o "$tmp"; then
              # Use file size to avoid parsing issues with wc/tr/newlines
              local sz
              sz=$(wc -c < "$tmp" 2>/dev/null || echo 0)
              case "$sz" in
                ''|*[!0-9]*) sz=0 ;;
              esac
              if [ "$sz" -gt 20 ]; then rm -f "$tmp"; echo ok; return; fi
              # YAML empty; try JSON
              rm -f "$tmp"
              if curl -fsS "http://localhost:${port}/v3/api-docs" -o "$tmp"; then
                sz=$(wc -c < "$tmp" 2>/dev/null || echo 0)
                case "$sz" in
                  ''|*[!0-9]*) sz=0 ;;
                esac
                rm -f "$tmp"
                if [ "$sz" -gt 20 ]; then echo ok; else echo no; fi
              else
                rm -f "$tmp" 2>/dev/null || true
                echo no
              fi
            else
              # YAML request failed; try JSON directly
              if curl -fsS "http://localhost:${port}/v3/api-docs" -o "$tmp"; then
                local sz
                sz=$(wc -c < "$tmp" 2>/dev/null || echo 0)
                case "$sz" in
                  ''|*[!0-9]*) sz=0 ;;
                esac
                rm -f "$tmp"
                if [ "$sz" -gt 20 ]; then echo ok; else echo no; fi
              else
                rm -f "$tmp" 2>/dev/null || true
                echo no
              fi
            fi
          }

          # Wait up to ~8 minutes (240 * 2s)
          for i in $(seq 1 240); do
            # Fail fast if any service died
            for pidfile in *.pid; do
              [ -f "$pidfile" ] || continue
              pid=$(cat "$pidfile")
              if ! ps -p "$pid" >/dev/null 2>&1; then
                svc="${pidfile%.pid}"
                die "Service '$svc' exited before becoming ready."
              fi
            done

            A=$(probe 18080)
            D=$(probe 18081)
            E=$(probe 18082)
            C=$(probe 18083)

            echo "probe #$i  A=$A D=$D E=$E C=$C"
            if [ "$A$D$E$C" = "okokokok" ]; then
              echo "All APIs are up"
              break
            fi
            sleep 2
          done

          if [ "$A$D$E$C" != "okokokok" ]; then
            die "Timed out waiting for APIs to start."
          fi

      # Generate OpenAPI + move into docs via the Docs module (keeps your POM behavior)
      - name: Build docs module (generate OpenAPI + copy to docs)
        run: mvn -B -s .github/maven-settings.xml -DskipTests -Ddocs.skipOpenapi=false -f Crypto-Trader-Docs/pom.xml -N verify

      # Ensure the spec exists in docs while services are still up (fallback to live only here)
      - name: Ensure CT API spec exists (while services are up)
        run: |
          set -euo pipefail
          FILE="Crypto-Trader-Docs/docs/api/openapi-api.yaml"
          TMP="${FILE}.tmp"
          mkdir -p "$(dirname "$FILE")"

          if [ ! -s "$FILE" ]; then
            echo "Spec missing in docs; attempting to pull from live API (yaml, then json)…"
            # Try YAML first
            if curl -fsS http://localhost:18080/v3/api-docs.yaml -o "$TMP"; then
              if [ -s "$TMP" ]; then
                mv -f "$TMP" "$FILE"
              else
                echo "YAML fetch returned empty body; trying JSON…"
                rm -f "$TMP"
                if curl -fsS http://localhost:18080/v3/api-docs -o "$TMP"; then
                  if [ -s "$TMP" ]; then
                    # ReDoc accepts JSON as well; store JSON at .yaml path
                    mv -f "$TMP" "$FILE"
                  else
                    echo "::error::JSON fetch also returned empty body."
                    rm -f "$TMP"
                  fi
                else
                  echo "::error::JSON fetch failed."
                fi
              fi
            else
              echo "YAML fetch failed; trying JSON…"
              if curl -fsS http://localhost:18080/v3/api-docs -o "$TMP"; then
                if [ -s "$TMP" ]; then
                  mv -f "$TMP" "$FILE"
                else
                  echo "::error::JSON fetch returned empty body."
                  rm -f "$TMP"
                fi
              else
                echo "::error::JSON fetch failed."
              fi
            fi
          fi

          echo "Spec in docs:"
          ls -l "$FILE"
          test -s "$FILE"

      - name: Stop services
        if: always()
        run: |
          for f in api.pid data.pid engine.pid contact.pid; do
            [ -f "$f" ] && kill "$(cat "$f")" || true
          done

      # Coverage build (aggregate)
      - name: Run tests with coverage (aggregate)
        run: mvn -B -s .github/maven-settings.xml -ntp -Pcoverage -DskipITs=true -DfailIfNoTests=false clean verify

      - name: Set up .NET (for ReportGenerator)
        uses: actions/setup-dotnet@v4
        with:
          dotnet-version: 8.0.x

      - name: Install ReportGenerator & add to PATH
        run: |
          dotnet tool install --global dotnet-reportgenerator-globaltool
          echo "$HOME/.dotnet/tools" >> "$GITHUB_PATH"

      - name: Build single aggregate coverage site
        run: |
          reportgenerator \
            -reports:"Crypto-Trader-Coverage/target/site/jacoco-aggregate/jacoco.xml" \
            -targetdir:"Crypto-Trader-Docs/docs/coverage" \
            -reporttypes:"Html;HtmlChart;Badges" \
            -sourcedirs:. \
            -classdirectories:"**/target/classes" \
            -assemblymode:MergeByClass
          if [ -f Crypto-Trader-Docs/docs/coverage/index.htm ] && [ ! -f Crypto-Trader-Docs/docs/coverage/index.html ]; then
            cp Crypto-Trader-Docs/docs/coverage/index.htm Crypto-Trader-Docs/docs/coverage/index.html
          fi

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.x'
          cache: 'pip'

      - name: Install MkDocs Material
        working-directory: Crypto-Trader-Docs
        run: |
          python -m pip install --upgrade pip
          pip install mkdocs mkdocs-material

      - name: Build MkDocs site
        working-directory: Crypto-Trader-Docs
        run: mkdocs build --site-dir site

      # Copy spec from docs into built site; DO NOT fetch live here
      - name: Copy spec into site/api and verify
        run: |
          set -euo pipefail
          SRC="Crypto-Trader-Docs/docs/api/openapi-api.yaml"
          DST_DIR="Crypto-Trader-Docs/site/api"
          mkdir -p "$DST_DIR"
          cp -fv "$SRC" "$DST_DIR/openapi-api.yaml"

          # prevent Jekyll munging
          touch "Crypto-Trader-Docs/site/.nojekyll"

          # prove it’s in the artifact
          ls -l "$DST_DIR"
          sha256sum "$DST_DIR/openapi-api.yaml"
          test -s "$DST_DIR/openapi-api.yaml"

      - name: Configure Pages
        id: pages
        uses: actions/configure-pages@v5
        continue-on-error: true
        with:
          enablement: true

      - name: Verify built site is non-empty
        id: verify_site
        run: |
          SITE_DIR="Crypto-Trader-Docs/site"
          if [ -s "$SITE_DIR/index.html" ] && [ "$(find "$SITE_DIR" -type f | wc -l)" -gt 5 ]; then
            echo "site_ready=true" >> "$GITHUB_OUTPUT"
            echo "Site verified."
          else
            echo "site_ready=false" >> "$GITHUB_OUTPUT"
            echo "::warning::Site is missing or empty. Skipping upload and deploy."
          fi

      - name: Upload Pages artifact
        if: ${{ steps.verify_site.outputs.site_ready == 'true' }}
        uses: actions/upload-pages-artifact@v3
        with:
          path: Crypto-Trader-Docs/site

      - name: Stop Kafka (docker-compose)
        if: always()
        run: docker compose -f infra/kafka/docker-compose.yml down -v

  deploy:
    environment:
      name: github-pages
      url: ${{ steps.deployment.outputs.page_url }}
    runs-on: ubuntu-latest
    needs: build
    if: needs.build.result == 'success' && needs.build.outputs.pages_enabled == 'success' && needs.build.outputs.site_ready == 'true'
    permissions:
      pages: write
      id-token: write
    steps:
      - name: Deploy to GitHub Pages
        id: deployment
        uses: actions/deploy-pages@v4
